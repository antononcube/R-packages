---
title: "Generic recommender interface"
output:
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
    source_code: embed
runtime: shiny
---

```{r setup, include=FALSE}
library(shiny)
library(flexdashboard)
library(Matrix)
library(DT)
library(purrr)
library(dplyr)
library(stringr)
library(tibble)
library(tidyr)

library(OutlierIdentifiers)
library(SparseMatrixRecommender)
library(SMRMon)
library(LSAMon)

`%||%` <- function(x, y) if (is.null(x) || length(x) == 0) y else x

split_weighted_text <- function(text, prefix = NULL, drop_prefix = FALSE, valid_names = NULL) {
  if (is.null(text) || !nzchar(trimws(text))) return(NULL)

  tokens <- text |>
    strsplit(",") |>
    unlist(use.names = FALSE) |>
    str_trim()
  tokens <- tokens[nchar(tokens) > 0]

  if (!is.null(prefix)) {
    pattern <- paste0("^(", paste(prefix, collapse = "|"), "):")
    tokens <- tokens[str_detect(tokens, pattern)]
  }
  if (!length(tokens)) return(NULL)

  df <- str_split_fixed(tokens, ":", 3) |>
    as_tibble(.name_repair = "minimal") |>
    set_names(c("Prefix", "Value", "Score")) |>
    mutate(
      Score = suppressWarnings(as.numeric(Score)),
      Score = replace(Score, is.na(Score), 1),
      Name  = if (drop_prefix) Value else paste(Prefix, Value, sep = ":")
    ) |>
    select(Name, Score)

  if (!is.null(valid_names)) {
    df <- df |> filter(Name %in% valid_names)
  }
  if (!nrow(df)) return(NULL)
  setNames(df$Score, df$Name)
}

normalize_profile <- function(x) {
  if (is.null(x) || !length(x)) return(NULL)
  max_abs <- max(abs(x))
  if (isTRUE(all.equal(max_abs, 0))) return(NULL)
  x / max_abs
}

profile_from_free_text <- function(lsa, text, type = c("terms", "topics"), allowed) {
  type <- match.arg(type)
  mat <- switch(
    type,
    terms  = lsa |> LSAMonRepresentByTerms(query = text) |> LSAMonTakeValue(),
    topics = lsa |> LSAMonRepresentByTopics(query = text) |> LSAMonTakeValue() |>
      SMRApplyTermWeightFunctions("None", "None", "Cosine")
  )
  vec <- colSums(mat)
  vec <- vec[abs(vec) > 0]
  if (!length(vec)) return(NULL)

  prefix <- if (type == "terms") "Word" else "Topic"
  names(vec) <- paste(prefix, names(vec), sep = ":")
  vec <- vec[names(vec) %in% allowed]
  normalize_profile(vec)
}
```

```{r data, include=FALSE}
load("smrGoods.RData")
load("lsaGoods.RData")
load("dfGoods.RData")

lsRecommenders <- list(Goods = smrGoods) |>
  map(~ .x |> SMRMonApplyTermWeightFunctions("None", "None", "Cosine"))
lsLSAObjects <- list(Goods = lsaGoods)
lsData       <- list(Goods = dfGoods)
```

Parameters {.sidebar}
=======================================================================

```{r}
selectInput(
  "recommender",
  "Type:",
  choices = setNames(names(lsRecommenders), paste(names(lsRecommenders), "recommender")),
  selected = "Goods"
)

sliderInput(
  "numberOfRecs",
  "Number of recommendations:",
  min = 1, max = 300, value = 10, step = 1
)
```

```{r}
selectedObjects <- reactive({
  req(input$recommender)
  list(
    smr = lsRecommenders[[input$recommender]],
    lsa = lsLSAObjects[[input$recommender]],
    data = lsData[[input$recommender]]
  )
})

smrObj <- reactive(selectedObjects()$smr)
lsaObj <- reactive(selectedObjects()$lsa)
dfData <- reactive(selectedObjects()$data)

tagTypes <- reactive({
  smrObj() |> SMRMonTakeTagTypes()
})
```

```{r}
uiOutput("tagWeightInputs")

output$tagWeightInputs <- renderUI({
  tagTypes() |>
    map(~ sliderInput(
      inputId = paste0(.x, "Weight"),
      label   = paste0(.x, " weight:"),
      min = 0, max = 1, value = 1, step = 0.01
    )) |>
    tagList()
})
```

```{r}
tagTypeWeights <- reactive({
  types <- tagTypes()
  req(types)
  map_dbl(types, ~ input[[paste0(.x, "Weight")]] %||% 1) |>
    set_names(types)
})
```

Recommendations
=======================================================================

Row {data-height=400}
-----------------------------------------------------------------------

### Tags

```{r}
textAreaInput(
  "tagsText",
  "Tag text (metadata)",
  placeholder = "Good:milk, Country:denmark, Good:ham:1.1",
  width = "600px", rows = 8
)

lsTagsProf <- reactive({
  text <- input$tagsText
  if (!nzchar(text)) return(NULL)
  prof <- split_weighted_text(text, valid_names = colnames(smrObj()$M))
  if (is.null(prof)) return(NULL)
  prof[!str_detect(names(prof), "^Item:")]
})

lsNNItems <- reactive({
  text <- input$tagsText
  if (!nzchar(text)) return(NULL)
  split_weighted_text(
    text,
    prefix = "Item",
    drop_prefix = TRUE,
    valid_names = rownames(smrObj()$M)
  )
})
```

Known tags:

```{r}
renderText({
  prof <- lsTagsProf()
  if (is.null(prof)) "—" else paste(names(prof), collapse = ", ")
})
```

### Free text

```{r}
textAreaInput(
  "freeText",
  "Free text (description)",
  placeholder = "Milk unverbalised",
  width = "600px", rows = 8
)

lsFreeWordsProf <- reactive({
  text <- input$freeText
  if (!nzchar(text)) return(NULL)
  profile_from_free_text(
    lsa = lsaObj(),
    text = text,
    type = "terms",
    allowed = colnames(smrObj()$M)
  )
})

lsFreeTopicsProf <- reactive({
  text <- input$freeText
  if (!nzchar(text)) return(NULL)
  profile_from_free_text(
    lsa = lsaObj(),
    text = text,
    type = "topics",
    allowed = colnames(smrObj()$M)
  )
})

lsFreeProf <- reactive({
  c(lsFreeWordsProf(), lsFreeTopicsProf())
})
```

Extracted words and topics:

```{r}
DT::renderDT({
  prof <- lsFreeProf()
  validate(need(!is.null(prof), "Enter free text to extract descriptors."))
  tibble(Word = names(prof), Score = unname(prof))
},
  extensions = "Scroller",
  options = list(scrollX = TRUE, scrollY = 300, scroller = TRUE),
  server = FALSE
)
```

Row {.tabset}
-----------------------------------------------------------------------

### Recommendations with both tags and free text

```{r}
lsProf <- reactive({
  c(lsTagsProf(), lsFreeProf())
})

DT::renderDT({
  profile <- lsProf()
  validate(need(!is.null(profile), "Provide tags and/or free text to get recommendations."))

  smrObj() |>
    SMRMonApplyTagTypeWeights(weights = tagTypeWeights(), default = 1) |>
    SMRMonRecommendByProfile(
      profile = profile,
      nrecs = input$numberOfRecs,
      normalizeQ = TRUE
    ) |>
    SMRMonJoinAcross(dfData()) |>
    SMRMonTakeValue()
},
  extensions = "Scroller",
  options = list(scrollX = TRUE, scrollY = 300, scroller = TRUE),
  selection = "none",
  server = FALSE
)
```

### Recommendations with items

```{r}
DT::renderDT({
  history <- lsNNItems()
  validate(need(!is.null(history), "Add Item:... entries in the tag box to pivot on items."))

  smrObj() |>
    SMRMonApplyTagTypeWeights(weights = tagTypeWeights(), default = 1) |>
    SMRMonRecommend(
      history = history,
      nrecs = input$numberOfRecs,
      normalizeQ = TRUE,
      removeHistoryQ = FALSE
    ) |>
    SMRMonJoinAcross(dfData()) |>
    SMRMonTakeValue()
},
  extensions = "Scroller",
  options = list(scrollX = TRUE, scrollY = 300, scroller = TRUE),
  selection = "none",
  server = FALSE
)
```

Profiles
=======================================================================

Row {data-height=400}
-----------------------------------------------------------------------

### Items

```{r}
textAreaInput(
  "profileTagsText",
  "Items text (points)",
  width = "600px", rows = 8
)

lsItemsHist <- reactive({
  text <- input$profileTagsText
  if (!nzchar(text)) return(NULL)
  split_weighted_text(
    text,
    prefix = "Item",
    drop_prefix = TRUE,
    valid_names = rownames(smrObj()$M)
  )
})
```

Known items:

```{r}
renderText({
  items <- lsItemsHist()
  if (is.null(items)) "—" else paste(names(items), collapse = ", ")
})
```

### Free text

```{r}
textAreaInput(
  "profileFreeText",
  "Free text (description)",
  placeholder = "Milk unverbalised",
  width = "600px", rows = 8
)

lsProfileFreeWordsProf <- reactive({
  text <- input$profileFreeText
  if (!nzchar(text)) return(NULL)
  profile_from_free_text(
    lsa = lsaObj(),
    text = text,
    type = "terms",
    allowed = colnames(smrObj()$M)
  )
})

lsProfileFreeTopicsProf <- reactive({
  text <- input$profileFreeText
  if (!nzchar(text)) return(NULL)
  profile_from_free_text(
    lsa = lsaObj(),
    text = text,
    type = "topics",
    allowed = colnames(smrObj()$M)
  )
})

lsProfileFreeProf <- reactive({
  c(lsProfileFreeWordsProf(), lsProfileFreeTopicsProf())
})

dfItemsByFreeText <- reactive({
  prof <- lsProfileFreeProf()
  req(prof)

  smrObj() |>
    SMRMonApplyTagTypeWeights(weights = tagTypeWeights(), default = 1) |>
    SMRMonRecommendByProfile(
      profile = prof,
      nrecs = input$numberOfRecs,
      normalizeQ = TRUE
    ) |>
    SMRMonTakeValue()
})

dfProfileByFreeText <- reactive({
  items <- dfItemsByFreeText()
  req(items)

  history <- setNames(items, c("Rating", "Index", "Item"))

  smrObj() |>
    SMRMonProfile(
      history = history,
      tagTypesQ = TRUE,
      normalizeQ = TRUE
    ) |>
    SMRMonTakeValue()
})
```

Extracted words and topics:

```{r}
DT::renderDT({
  prof <- lsProfileFreeProf()
  validate(need(!is.null(prof), "Enter profile free text to see descriptors."))
  tibble(Word = names(prof), Score = unname(prof))
},
  extensions = "Scroller",
  options = list(scrollX = TRUE, scrollY = 300, scroller = TRUE),
  server = FALSE
)
```

Row {.tabset}
-----------------------------------------------------------------------

### Profile of items

```{r}
dfProfileByItemsHist <- reactive({
  history <- lsItemsHist()
  if (is.null(history) || !length(history)) return(NULL)

  smrObj() |>
    SMRMonApplyTagTypeWeights(weights = tagTypeWeights(), default = 1) |>
    SMRMonProfile(
      history = history,
      tagTypesQ = TRUE,
      normalizeQ = TRUE
    ) |>
    SMRMonTakeValue()
})
```

```{r}
DT::renderDT({
  validate(need(!is.null(dfProfileByItemsHist()), "Provide items to build a profile."))
  dfProfileByItemsHist()
},
  extensions = "Scroller",
  options = list(scrollX = TRUE, scrollY = 300, scroller = TRUE),
  server = FALSE
)
```

### Profile by free text

```{r}
DT::renderDT({
  validate(need(!is.null(dfProfileByFreeText()), "Provide profile free text."))
  dfProfileByFreeText()
},
  extensions = "Scroller",
  options = list(scrollX = TRUE, scrollY = 300, scroller = TRUE),
  server = FALSE
)
```

### Profile by both items and free text

```{r}
DT::renderDT({
  items_profile <- dfProfileByItemsHist()
  free_profile  <- dfProfileByFreeText()
  validate(need(!is.null(items_profile) || !is.null(free_profile),
                "Provide items and/or free text for fused profile."))

  bind_rows(items_profile %||% tibble(), free_profile %||% tibble()) |>
    group_by(TagType, Tag) |>
    summarise(Score = sum(Score), .groups = "drop") |>
    arrange(desc(Score)) |>
    select(Score, TagType, Tag)
},
  extensions = "Scroller",
  options = list(scrollX = TRUE, scrollY = 300, scroller = TRUE),
  server = FALSE
)
```

Summary
=======================================================================

### Dimensions of the recommender matrix

```{r}
renderText({
  dims <- smrObj() |> SMRMonTakeM() |> dim()
  glue::glue("Rows: {dims[1]}, Columns: {dims[2]}")
})
```

### Tag types and ranges

```{r}
DT::renderDT({
  smrObj() |> SMRMonTakeTagTypeRanges()
},
  options = list(pageLength = 5, scrollX = TRUE),
  server = FALSE
)
```

References
=======================================================================

#### In brief

The data of the Goods recommender was generated with the R package
[RandomDataGenerator](https://github.com/antononcube/R-packages/tree/master/RandomDataFrameGenerator), [AAp4].

The recommenders were made with the packages
[`SMRMon-R`](https://github.com/antononcube/R-packages/tree/master/SMRMon-R)
and
[`LSAMon-R`](https://github.com/antononcube/R-packages/tree/master/LSAMon-R),
[AAp1, AAp2, AAp3].


#### Packages

[AAp1] Anton Antonov,
[Sparse Matrix Recommender framework functions, R-package](https://github.com/antononcube/R-packages/tree/master/SparseMatrixRecommender),
(2019),
[R-packages at GitHub/antononcube](https://github.com/antononcube/R-packages).

[AAp2] Anton Antonov,
[Sparse Matrix Recommender Monad, R-package](https://github.com/antononcube/R-packages/tree/master/SMRMon-R),
(2019),
[R-packages at GitHub/antononcube](https://github.com/antononcube/R-packages).

[AAp3] Anton Antonov,
[Latent Semantic Analysis Monad, R-package](https://github.com/antononcube/R-packages/tree/master/LSAMon-R),
(2019),
[R-packages at GitHub/antononcube](https://github.com/antononcube/R-packages).

[AAp4] Anton Antonov,
[Random Data Generators, R-package](https://github.com/antononcube/R-packages/tree/master/RandomDataGenerators),
(2021-2025),
[R-packages at GitHub/antononcube](https://github.com/antononcube/R-packages).
